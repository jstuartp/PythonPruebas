#!/usr/bin/env seiscomp-python
# -*- coding: utf-8 -*-
from obspy.clients.fdsn import Client
from obspy import read, UTCDateTime
import sys
import traceback
import datetime
import os
from seiscomp import core, client, io, math, logging
from seiscomp import client, datamodel
from seiscomp.client import Protocol



#Se crea el objeto cliente FDSN para obtener datos y el inventario
host = ("http://163.178.171.47:8080")  # SEISCOMP servidor Virtual
#host = ("http://localhost:8080")  # SEISCOMP computadora local
myClient = Client(host)
total = myClient.get_stations()
networks = myClient.get_stations(level="network")
rutaLog ="/home/lis/waves/corta/cortaLog.log"     #archivo de log




class EventListener(client.Application):

    def __init__(self, argc, argv):
        client.Application.__init__(self, argc, argv)
        self.setMessagingEnabled(True)
        self.setDatabaseEnabled(False, False)
        self.setPrimaryMessagingGroup(Protocol.LISTENER_GROUP)
        self.addMessagingSubscription("EVENT")
        self.setLoggingToStdErr(True)

    def doSomethingWithEvent(self, obj):
        event = datamodel.Event.Cast(obj)
        fechaEvento = str(event.creationInfo().creationTime())
        fechaEvento = fechaEvento.replace(" ","")
        fechaEvento = fechaEvento.replace(":", "_")
        fechaEvento = fechaEvento.replace(".", "_")
        rutaWaves = "/home/lis/waves/corta/"+event.publicID()+fechaEvento+"/"
        now = core.Time.GMT()
        try:
            os.stat(rutaWaves)
        except:
            os.mkdir(rutaWaves)

        try:
            archivo = open(rutaLog, "a")
            archivo.write("\n\n\n--EXITO--PROCESANDO NUEVO EVENTO %s" % event.publicID())
            archivo.write("\n--EXITO--Fecha del evento %s" % event.creationInfo().creationTime())
            archivo.write("\n--EXITO--Fecha de procesamiento %s" % str(now))
            archivo.close()
            tiempo = event.creationInfo().creationTime()


            # Substract 5 minutes for the start time
            #start = now - core.TimeSpan(300, 0)
            inicio = tiempo - core.TimeSpan(300, 0)  # resta 5 minutos a la hora fija

            fin = tiempo + core.TimeSpan(300, 0)  # suma 5 minutos a la hora fija
            utcfin= UTCDateTime(fin)
            utcinicio= UTCDateTime(inicio)
            utctiempo = UTCDateTime(tiempo)
            lista = []

            for n in range(len(networks)):
                # print(total[n].code)
                for s in range(len(total.networks[n].stations)):
                    #print(total.networks[n].stations[s].code)

                    try:
                        st = myClient.get_waveforms(total[n].code, total.networks[n].stations[s].code, "**", "HN*",
                                                  utcinicio, utcfin, attach_response=True)
                        #instucciones de log
                        archivo = open(rutaLog, "a")
                        archivo.write("\n--EXITO--Pidiendo Stream para %s" % total.networks[n].stations[s].code)
                        archivo.close()
                        #fin de log
                    except Exception as err:
                        archivo = open(rutaLog, "a")
                        archivo.write("\n--FALLO EN LECTURA--No data for station  %s" % total.networks[n].stations[s].code)
                        #archivo.write(f"\nDescripcion del error:  {err.encode('utf-8')}")
                        archivo.close()
                        #print(f"FALLO TRY 1 Descripcion del error: {err}")


                    else:  # de existir datos continua con el calculo
                        #st.merge()
                        # copia para quitar respuesta
                        #strNew = st.copy()
                        try:
                            st.merge()
                            # copia para quitar respuesta
                            strNew = st.copy()
                            rutaArchivo = rutaWaves + utctiempo.strftime("%m-%d-%Y_%H_%M_%S") + "_" + \
                                          total.networks[n].stations[s].code + ".mseed"
                            # guardar el stream en archivo mseed
                            strNew.write(rutaArchivo, format="MSEED")

                        except Exception as err:
                            #print("Error en lectura de datos para la estación %s " % total.networks[n].stations[s].code)
                            archivo = open(rutaLog, "a")
                            archivo.write(
                                "\n--FALLO EN ESCRITURA-- No data written for station %s " % total.networks[n].stations[s].code)
                            #archivo.write(f"\nDescripción del error:  {err}")
                            archivo.close()
                            #print(f"FALLO TRY 2 Descripcion del error: {err}")
        except Exception as err:
            archivo = open(rutaLog, "a")
            archivo.write("\n--FALLO FATAL-- Something is broken" )
            archivo.write(f"\nError detail:  {err}")
            archivo.close()


        archivo = open(rutaLog, "a")
        archivo.write("\n--TERMINE TODO EL PROCESO--")
        # archivo.write( "\nDescripción del error:  %s" % str(err.__str__()))
        archivo.close()
        print("TERMINE DE ACTUALIZAR")

            #traceback.print_exc()

    def updateObject(self, parentID, scobject):
        # called if an updated object is received
        event = datamodel.Event.Cast(scobject)
        if event:
            print("Evento actualizado {}".format(event.publicID()))
            self.doSomethingWithEvent(event)

    def addObject(self, parentID, scobject):
        # called if a new object is received
        event = datamodel.Event.Cast(scobject)
        if event:
            print("Nuevo evento reportado {}".format(event.publicID()))
            self.doSomethingWithEvent(event)

    def run(self):
        # does not need to be reimplemented. it is just done to illustrate
        # how to override methods
        print("Hola! Estoy corriendo, esperando eventos.")
        return client.Application.run(self)


def main():
    app = EventListener(len(sys.argv), sys.argv)
    return app()


if __name__ == "__main__":
    sys.exit(main())